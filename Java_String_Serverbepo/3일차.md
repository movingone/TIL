# 3일차 MySQL과 데이터베이스

- Database와 MySQL
- 테이블 만들기
- Spring에서 DB사용하기

---

**컴퓨터의 핵심부품**

CPU : 연산(덧셈, 곱셈)

RAM : 메모리(렘8, 16), 임시기억장치

DISK : 하드디스크, SSD, 장기기억장치

<br>

**서버를 실행시켜 API동작까지 일어나는 일**

1. 개발하고 있는 서버(코드)는 DISK에 잠들어 있다
2. 서버를 실행시키면 DISK에 있는 코드 정보가 RAM으로 복사된다
3. API가 실행되면 '연산'이 수행되며 CPU와 RAM을 왔다갔다 한다
4. 즉 POST API를 통해 생긴 유저 정보는 RAM(메모리)에 쓰여 있다
5. 서버가 종로되면 RAM에 있는 모든 정보는 사라진다
6. 때문에 다시 서버를 시작하면 유저 정보가 없다(그러므로 워드, 엑셀에서 저장은 DISK에 장기기록을 뜻한다)


**그렇다면 서버에서 DISK에 저장하는 방법은?**

1. File클래스를 이용해 직접 Disk에 접근할 수도 있음
2. Database를 이용해 저장

> Database : 데이터를 구조화 시켜 저장하는 것

MySQL : RDB(Relational Database)로 표처럼 구조화 시켜 사용

SQL(Structured Query Language) : 표처럼 구조화된 데이터를 조회하는 언어

<br>

MySQL 정수타입

     tinyint : 1바이트 정수
     int : 4바이트 정수
     bigint : 8바이트 정수

실수타입

     double : 8바이트 정수
     decimal(A, B) : 소수점을 B개 가지고 있는 전체 A자리 실수
     ex) Decimal(4,2) = 12.23

문자열 타입

     char(A) : A 글자가 들어갈 수 있는 문자열(고정)
     varchar(A) : 최대 A 글자가 들어갈 수 있는 문자열(최대) 

날짜, 시간 타입

     date : 날짜, yyyy-MM-dd
     time : 시간, HH:mm:ss
     datetime : 날짜와 시간을 합친 타입, yyyy-MM-dd HH:mm:ss


> 데이터를 정의하는 언어로 DDL(Data Definition Language)라 함

<br>

데이터 생성, 조회, 수정, 삭제 -> **CRUD**

- 데이터 넣기

      INSERT INTO [테이블 이름] (필드1이름, 필드2이름, ....) VALUES (값1, 값2 ..)
- 데이터 조회

      SELECT * FROM [테이블 이름] WHERE [조건];
      
      조건에는 =, <=, !=, <, >, >=, between, in, not in등이 있다

- 데이터 수정

      UPDATE [테이블 이름] SET 필드1이름=값, 필드2이름=값, ... WHERE [조건];
      만약 [조건]을 붙이지 않으면, 모든 데이터가 업데이트 된다
- 데이터 삭제

      DELETE FROM [테이블 이름] WHERE [조건];
      [조건]을 붙이지 않으면, 모든 데이터가 삭제된다

> 이 4가지는 데이터를 조작하는 언어로 DML(Data Manipulation Language)라 한다


<br>

**Spring과 데이터베이스 연결하기**

yml 설정
```yml
spring:
  datasource:
    url: "jdbc:mysql://localhost/library"
    // 자바 데이터베이스 커낵터 db는 mysql 사용할 db는 library
    username: "root"
    password: "aa414802!"
    driver-class-name: com.mysql.cj.jdbc.Driver
      // 데이터 베이스에 접근할때 사용할 프로그램
```

메모리에 저장하던 유저 정보를 mysql에 저장하도록 바꾸기

`UserController`에 들어가서 바꿔줌

![](./3day%20image/JdbcTemplate.png)

Jdbc템플릿이 생성자를 만들어두면 자동으로 파라미터를 타고 들어와 설정되게 됨

고정된 sql이 아닌(?, ?)는 입력값에 따라 달라져야 하기에 ?로 처리


**GET API 변경**

![img.png](./3day%20image/GET api 변경.png)

간단히 람다로 변경도 가능

![img.png](./3day%20image/lamda변경.png)

<br>

**익명 클래스**

    주로 한 번만 사용되는 객체를 생성할 때 사용. 이름이 없으며, 간단한 인터페이스 구현에 사용됨
    
    - 인터페이스나 추상 클래스를 즉석에서 구현해 사용
    - 외부의 final이나 effectively final 변수에 접근가능

```java
button.addActionListener(new ActionListener() { // 익명클래스 사용해 메소드 구성함
    public void actionPerformed(ActionEvent e) {
        // 이곳에 클릭 시 수행할 동작을 정의합니다.
    }
});
```

**람다**

    자바8부터 도입되어 코드를 간결하게 만들며 함수형 프로그래밍을 지원함,
    주로 컬렉션의 요소를 처리하거나 이벤트 리스너 구현에 사용

```java
큰수찾기
@FunctionalInterface
interface MyNumber {
    int getMax(int num1, int num2);
}

public class LambdaExample {
    public static void main(String[] args) {
        MyNumber max = (x, y) -> (x >= y) ? x : y;
        System.out.println(max.getMax(10, 30));
    }
}


Runnable 인스턴스 생성 및 Thread 실행
public class RunnableExample {
    public static void main(String[] args) {
        Runnable runnable = () -> {
            for (int i = 0; i < 30; i++) {
                System.out.println(i);
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```

**함수형 프로그래밍**

    자료처리를 수학적 함수계산으로 취급하고, 상태와 가변 데이터를 멀리하는 프로그래밍
    명령형 프로그래밍 상태변경과 반대되어 함수의 응용을 강조, 순수함수를 사용해 프로그램 동작 예측가능

```java
public static void main(String[] args) {
    List<Integer> values = Arrays.asList(7, 5, 123, 5, 42, 95, 68, 30, 42);
    List<Integer> result = values.stream()
                                  .filter(number -> number < 50)
                                  .distinct()
                                  .sorted()
                                  .collect(Collectors.toList());
    System.out.println(result);
}

원본 리스트 values는 변경되지 않으며, 각 단계에서 순수 함수를 사용하여 연산을 수행
불변성과 부작용이 없는 연산을 보여줌
```

**@FunctionalInterface**

    자바8에서 도입된 어노테이션으로, 해당 인터페이스가 함수형 인터페이스임을 나타냄
    함수형 인터페이스는 정확히 하나의 추상 메서드를 가져야 하며, 어노테이션은 이러한 인터페이스를 
    명시적으로 표시하는데 사용 또한 함수형 인터페이스의 계약 위반시 컴파일러에게 오류 메시지 생성 요구

```java
@FunctionalInterface
public interface SimpleFunctionalInterface {
    void execute();
}
execute 라는 하나의 추상 메서드를 가지고 있음, 람다 표현식, 메서드 참조, 생성자 참조를 통해 인터페이스의 인스턴스 생성 가능
```

**스트림 API**

    스트림 API를 사용하면 데이터를 필터링, 정렬, 변환, 그룹화하는 등의 작업을 람다식을 이용하여 간단하고 가독성 높은 코드로 작성할 수 있으며, 병렬 처리를 통해 성능을 향상시킬 수 있다

**메소드 레퍼런스**

    자바에서 람다식으로 표현되는 메소드의 실행 로직이 이미 존재하는 메소드와 동일한 경우, 해당 메소드를 직접 참조하는 방식
    이를 통해 가독성 향상, 중복 줄임, 간결한 표현 가능하다

```java
public static void main(String[] args) {
    List<String> words = Arrays.asList("hello", "world", "java", "stream");

    // 람다 표현식을 사용한 경우
    words.forEach(word -> System.out.println(word));

    // 메소드 레퍼런스를 사용한 경우
    words.forEach(System.out::println);
}
```

---

### 문제

1. 자바의 람다식은 왜 등장했을까?

        함수형 프로그래밍을 지원하기 위해 등장(함수형 스타일 프로그래밍을 위해)
        
        1. 간결성 : 익명 함수를 간결하게 표현할 수 있으며, 반복적인 코드를 줄여 가독성을 향상
        2. 익명 함수 : 메서드를 정의하지 않고도 코드 블록을 직접 전달할 수 있으므로, 콜백이나 이벤트 처리와 같은 곳에서 유용하게 사용
        3. 함수형 프로그래밍 : 자바에서도 함수를 값으로 다루고, 고차 함수를 사용할 수 있게 됨
        4. 병렬 프로그래밍 : 함수형 스타일로 작성된 코드는 상태 변경이 없으므로 스레드 간의 경합 조건과 교착 상태 같은 문제를 피하기가 쉬움
        5. 트림 API와의 호환성 : 스트림 API는 데이터를 처리하기 위한 함수형 스타일의 API이며, 람다식을 사용하여 데이터를 간결하게 처리

<br>

2. 람다식과 익명 클래스는 어떤 관계가 있을까?

       익명클래스는 클래스 선언과 인스턴스가 필요하지만 람다식은 더 간결한 문법으로 직관적이다

    ```java
   1. 구문의 간결성
   
    // 익명 클래스
    Runnable runnable1 = new Runnable() {
    @Override
    public void run() {
    System.out.println("Hello, anonymous class!");
    }
    };
    
    // 람다식
    Runnable runnable2 = () -> System.out.println("Hello, lambda expression!");
   
   
   2. 타입 추론
         람다식은 컴파일러가 대부분의 경우 타입을 추론할 수 있어서 타입을 명시적으로 선언하지 않아도 됨
   
   // 익명 클래스
    ActionListener listener1 = new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
        System.out.println("Button clicked!");
        }
        };
    
    // 람다식
    ActionListener listener2 = (ActionEvent e) -> {
    System.out.println("Button clicked!");
    };
    ```


3. 람다식의 문법은 어떻게 될까?

    ```java
    (parameter1, parameter2, ...) -> { body }
    ```
   파라미터 : 람다식의 입력 매개변수로 파라미터가 없다면 빈 괄호로() 나타낼 수 있음, 하나의 파라미터면 괄호 생략 가능 () -> a + b

   화살표 : 본문(body)을 구분하는 구분자

   매서드 본문 : 하나의 표현식이나 여러 개의 문장으로 구성될 수 있음

---

### 출처

https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C-%EC%98%AC%EC%9D%B8%EC%9B%90 - 10강 ~ 13강